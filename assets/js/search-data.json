{
  
    
        "post0": {
            "title": "Effective LSTMs for Target Dependent Sentiment Classification [Part 2]",
            "content": "The full notebook is available here . Install required packages . %%capture !pip install pytorch-lightning !pip install torchmetrics . Import required packages . import pickle from collections import Counter, OrderedDict from pathlib import Path from typing import Any, Dict, List, Optional, Tuple, Union from urllib.request import urlretrieve import numpy as np from tqdm import tqdm import pytorch_lightning as pl import torch import torch.nn as nn import torch.nn.functional as F import torchmetrics import torchtext from pytorch_lightning import loggers as pl_loggers from pytorch_lightning.callbacks import ModelCheckpoint from torch.nn.utils.rnn import (pack_padded_sequence, pad_packed_sequence, pad_sequence) from torch.utils.data import DataLoader, Dataset, random_split from torchtext.data import get_tokenizer from torchtext.vocab import Vectors, Vocab # For repoducibility pl.utilities.seed.seed_everything(seed=2401, workers=True) . Global seed set to 2401 . 2401 . Define dataset, data module class, utils function . =====Dataset File Format===== . Each instance consists three lines: . sentence (the target is replaced with $T$) | target | polarity label (0: neutral, 1:positive, -1:negative) | . Example: . i agree about arafat . i mean , shit , they even gave one to $T$ ha . it should be called &#39;&#39; the worst president &#39;&#39; prize . . jimmy carter . -1 . class TqdmUpTo(tqdm): &quot;&quot;&quot;From https://github.com/tqdm/tqdm/blob/master/examples/tqdm_wget.py&quot;&quot;&quot; def update_to(self, blocks=1, bsize=1, tsize=None): &quot;&quot;&quot; Parameters - blocks: int, optional Number of blocks transferred so far [default: 1]. bsize: int, optional Size of each block (in tqdm units) [default: 1]. tsize: int, optional Total size (in tqdm units). If [default: None] remains unchanged. &quot;&quot;&quot; if tsize is not None: self.total = tsize # pylint: disable=attribute-defined-outside-init self.update(blocks * bsize - self.n) # will also set self.n = b * bsize class Tokenizer(): def __init__(self, tokenizer: Any): self.counter = Counter([&#39;&lt;pad&gt;&#39;, &#39;&lt;unk&gt;&#39;]) self.tokenizer = tokenizer self.vocab = self.update_vocab() def update_vocab(self): sorted_by_freq_tuples = sorted(self.counter.items(), key=lambda x: x[1], reverse=True) ordered_dict = OrderedDict(sorted_by_freq_tuples) self.vocab = torchtext.vocab.vocab(ordered_dict, min_freq=1) self.vocab.set_default_index(self.vocab[&#39;&lt;unk&gt;&#39;]) def fit_on_texts(self, texts: List[str]): &quot;&quot;&quot; Updates internal vocabulary based on a list of texts. &quot;&quot;&quot; # lower and tokenize texts to sequences for text in texts: self.counter.update(self.tokenizer(text)) # self.counter.update([t.lower().strip() for t in text.split()]) self.update_vocab() def texts_to_sequences(self, texts: List[str], reverse: bool=False, tensor: bool=True) -&gt; List[int]: sequences = [] for text in texts: seq = [self.vocab[word] for word in self.tokenizer(text)] if reverse: seq = seq[::-1] if tensor: seq = torch.tensor(seq) sequences.append(seq) return sequences def _load_data_from(path: Union[str, Path]) -&gt; Tuple[List[List[str]], List[List[str]], List[set]]: &quot;&quot;&quot; Create a dataset from a file path Return: a TwitterDataset object &quot;&quot;&quot; sentences = [] targets = [] sentiments = [] with open(path) as f: lines = f.readlines() # Read the file line by line and # check the relative index to parse the data according to the format. for i, line in enumerate(lines): index = i % 3 # compute the relative index if index == 0: sentences.append(line[:-1]) elif index == 1: targets.append(line[:-1]) elif index == 2: sentiments.append(line.strip()) return sentences, targets, sentiments def download_url(url, filename, directory=&#39;.&#39;): &quot;&quot;&quot;Download a file from url to filename, with a progress bar.&quot;&quot;&quot; if not os.path.exists(directory): os.makedirs(directory) path = os.path.join(directory, filename) with TqdmUpTo(unit=&quot;B&quot;, unit_scale=True, unit_divisor=1024, miniters=1) as t: urlretrieve(url, path, reporthook=t.update_to, data=None) # nosec return path def _preprocess_data(data, tokenizer): sents, targets, sentiments = data l_texts = [] r_texts = [] texts = [] for i, sent in enumerate(sents): l_text, _, r_text = sent.partition(&quot;$T$&quot;) l_text = l_text + &#39; &#39; + targets[i] r_text = targets[i] + &#39; &#39; + r_text text = l_text + &#39; &#39; + targets[i] + &#39; &#39; + r_text l_texts.append(l_text) r_texts.append(r_text) texts.append(text) # Generate left, right and target sequences l_sequences = tokenizer.texts_to_sequences(l_texts) r_sequences = tokenizer.texts_to_sequences(r_texts, reverse=True) target_sequences = tokenizer.texts_to_sequences(targets) sequences = tokenizer.texts_to_sequences(texts) # Calcuate length of each sequence in the left, right sequences l_lens = torch.tensor([len(seq) for seq in l_sequences]) r_lens = torch.tensor([len(seq) for seq in r_sequences]) lens = torch.tensor([len(seq) for seq in sequences]) # Padding sequences l_sequences = pad_sequence(l_sequences, batch_first=True) r_sequences = pad_sequence(r_sequences, batch_first=True) target_sequences = pad_sequence(target_sequences, batch_first=True) sequences = pad_sequence(sequences, batch_first=True) #Convert sentiment text to number sentiments = list(map(lambda x: int(x), sentiments)) sentiments = torch.tensor(sentiments) + 1 # increment labels by 1 # Double Checking assert len(r_lens) == len(r_sequences) assert len(l_lens) == len(l_sequences) assert len(l_lens) == len(sentiments) data = [] for i in range(len(sentiments)): sample = { &#39;padded_l_sequence&#39;: l_sequences[i], &#39;padded_r_sequence&#39;: r_sequences[i], &#39;padded_sequence&#39;: sequences[i], &#39;l_len&#39;: l_lens[i], &#39;r_len&#39;: r_lens[i], &#39;len&#39;: lens[i], &#39;padded_target_sequence&#39;: target_sequences[i], &#39;sentiment&#39;: sentiments[i] } data.append(sample) return data def build_vocab(tokenizer, data): sentences, targets = data texts = [] for i, sent in enumerate(sentences): texts.append(sent.replace(&#39;$T$&#39;, targets[i])) tokenizer.fit_on_texts(texts) def load_pretrained_word_embeddings(options: Dict[str, Any]): return torchtext.vocab.GloVe(options[&#39;name&#39;], options[&#39;dim&#39;]) def create_embedding_matrix(word_embeddings: Vectors, vocab: Vocab, path: Union[str, Path]): if os.path.exists(path): print(f&#39;loading embedding matrix from {path}&#39;) embedding_matrix = pickle.load(open(path, &#39;rb&#39;)) else: embedding_matrix = torch.zeros((len(vocab), word_embeddings.dim), dtype=torch.float) # words that are not availabel in the pretrained word embeddings will be zeros for word, index in vocab.get_stoi().items(): embedding_matrix[index] = word_embeddings.get_vecs_by_tokens(word) # save embedding matrix pickle.dump(embedding_matrix, open(path, &#39;wb&#39;)) return embedding_matrix . class TwitterDataset(Dataset): def __init__(self, data): self.data = data def __len__(self): return len(self.data) def __getitem__(self, idx): return self.data[idx] TRAIN_DS_URL = &quot;https://raw.githubusercontent.com/songyouwei/ABSA-PyTorch/master/datasets/acl-14-short-data/train.raw&quot; TEST_DS_URL = &quot;https://raw.githubusercontent.com/songyouwei/ABSA-PyTorch/master/datasets/acl-14-short-data/test.raw&quot; class Twitter(pl.LightningDataModule): &quot;&quot;&quot; The Twitter dataset is ndwritten character digits derived from the NIST Special Database 19 &quot;&quot;&quot; def __init__(self, tokenizer: Tokenizer, opts: Dict[str, Any]): super().__init__() self.tokenizer = tokenizer self.batch_size = opts[&#39;batch_size&#39;] self.num_workers = opts[&#39;num_workers&#39;] self.on_gpu = opts[&#39;on_gpu&#39;] self.mapping = {&quot;negative&quot;: 0, &quot;neutral&quot;: 1, &quot;positive&quot;: 2} self.inverse_mapping = {v: k for k, v in enumerate(self.mapping)} def prepare_data(self, *args, **kwargs) -&gt; None: # Download the data train_path = &quot;download/raw_data/train.raw&quot; test_path = &quot;download/raw_data/test.raw&quot; if not os.path.exists(train_path): self.train_path = download_url(TRAIN_DS_URL, &quot;train.raw&quot;, &quot;download/raw_data&quot;) else: self.train_path = train_path if not os.path.exists(test_path): self.test_path = download_url(TEST_DS_URL, &quot;test.raw&quot;, &quot;download/raw_data&quot;) else: self.test_path = test_path def setup(self, stage: str = None) -&gt; None: if stage == &#39;fit&#39; or stage is None: # Load data from file train_data = _load_data_from(self.train_path) test_data = _load_data_from(self.test_path) # Preprocess data self.train_data = _preprocess_data(train_data, self.tokenizer) self.test_data = _preprocess_data(test_data, self.tokenizer) # In the paper, the author use the test set as validation set self.val_data = self.test_data elif stage == &#39;test&#39;: test_data = _load_data_from(self.test_path) self.test_data = _preprocess_data(test_data, self.tokenizer) def train_dataloader(self): # Create Dataset object train_ds = TwitterDataset(self.train_data) # Create Dataloader return DataLoader( train_ds, shuffle=True, batch_size=self.batch_size, num_workers=self.num_workers, pin_memory=self.on_gpu, ) def val_dataloader(self): val_ds = TwitterDataset(self.val_data) return DataLoader( val_ds, shuffle=False, batch_size=self.batch_size, num_workers=self.num_workers, pin_memory=self.on_gpu, ) def test_dataloader(self): test_ds = TwitterDataset(self.test_data) return DataLoader( test_ds, shuffle=False, batch_size=self.batch_size, num_workers=self.num_workers, pin_memory=self.on_gpu, ) def __repr__(self): basic = f&quot;Twitter Dataset nNum classes: {len(self.mapping)} nMapping: {self.mapping} n&quot; if self.train_data is None and self.val_data is None and self.test_data is None: return basic x, y = next(iter(self.train_dataloader())) data = ( f&quot;Train/val/test sizes: {len(self.train_data)}, {len(self.val_data)}, {len(self.test_data)} n&quot; f&quot;Batch x stats: {(x.shape, x.dtype)} n&quot; f&quot;Batch y stats: {(y.shape, y.dtype)} n&quot; ) return basic + data . In the paper, the author trained the model on training set, and evaluated the performance on test set . Implement Model Architecture . We use Adam as our optimizer and using accuracy and f1 as our evaluating metrics, just like in the original paper. Also, we use cross entropy function to calculate our loss, which is the de-facto function for multi-class classification task. . TD-LSTM . The architecture has a embedding layer, 2 LSTM layers and 1 dense layer. . Embedding layer: | . Convert the sequences to word vectors using pre-trained Glove word embeddings . 2 LSTM layers: | . One layer is used for the [left context + target] sequences, and one is used for the [target + right context] sequences. . Dense layer: | . We concate the 2 hidden states from the LSTM layers and feed it into the Dense layer. . To take into account of the target information, we make a slight modification on the $LSTM$ model. The basic idea is to model the preceding and following contexts surrounding the target string, so that contexts in both directions could be used as feature representations for sentiment classification. We believe that capturing such target-dependent context information could improve the accuracy of target-dependent sentiment classification. . Specifically, we use two $LSTM$ neural networks, a left one $LSTM_L$ and a right one $LSTM_R$, to model the preceding and following contexts respectively. An illustration of the model is shown in Figure 1. The input of $LSTM_L$ is the preceding contexts plus target string, and the input of $LSTM_R$ is the following contexts plus target string. We run $LSTM_L$ from left to right, and run $LSTM_R$ from right to left. We favor this strategy as we believe that regarding target string as the last unit could better utilize the semantics of target string when using the composed representation for sentiment classification. Afterwards, we concatenate the last hidden vectors of $LSTM_L$ and $LSTM_R$ , and feed them to a sof tmax layer to classify the sentiment polarity label. One could also try averaging or summing the last hidden vectors of $LSTM_L$ and $LSTM_R$ as alternatives. . from IPython.display import Image Image(filename=&#39;images/figure_1_image.png&#39;) . class TDLSTM(pl.LightningModule): def __init__(self, embeddings, hidden_size, num_layers=1, num_classes=3, batch_first=True, lr=1e-3, dropout=0, l2reg=0.01): super().__init__() embedding_dim = embeddings.shape[1] self.embedding = nn.Embedding.from_pretrained(embeddings) # load pre-trained word embeddings self.l_lstm = nn.LSTM(embedding_dim, hidden_size, num_layers, batch_first=batch_first, dropout=dropout) self.r_lstm = nn.LSTM(embedding_dim, hidden_size, num_layers, batch_first=batch_first, dropout=dropout) self.linear = nn.Linear(hidden_size*2, num_classes) self.lr = lr self.l2reg = l2reg # Define metrics self.train_acc = torchmetrics.Accuracy() self.val_acc = torchmetrics.Accuracy() self.val_f1 = torchmetrics.F1(num_classes=3, average=&#39;macro&#39;) self.test_acc = torchmetrics.Accuracy() self.test_f1 = torchmetrics.F1(num_classes=3, average=&#39;macro&#39;) def configure_optimizers(self): optim = torch.optim.Adam(self.parameters(), lr=self.lr, weight_decay=self.l2reg) return optim def forward(self, data): cols = [&#39;padded_l_sequence&#39;, &#39;padded_r_sequence&#39;, &#39;l_len&#39;, &#39;r_len&#39;] padded_l_seqs, padded_r_seqs, l_lens, r_lens = [data[col] for col in cols] # convert seq to word vector padded_l_embeds = self.embedding(padded_l_seqs) padded_r_embeds = self.embedding(padded_r_seqs) # pack the embeds padded_l_seq_pack = pack_padded_sequence(padded_l_embeds, l_lens.cpu(), batch_first=True, enforce_sorted=False) padded_r_seq_pack = pack_padded_sequence(padded_r_embeds, r_lens.cpu(), batch_first=True, enforce_sorted=False) _, (h_l, _) = self.l_lstm(padded_l_seq_pack) _, (h_r, _) = self.r_lstm(padded_r_seq_pack) h = torch.cat((h_l[-1], h_r[-1]), -1) # B x 2H out = self.linear(h) return out def training_step(self, batch, batch_idx): # pylint: disable=unused-argument sentiments = batch[&#39;sentiment&#39;] logits = self.forward(batch) loss = F.cross_entropy(logits, sentiments) scores = F.softmax(logits, dim=-1) self.train_acc(scores, sentiments) self.log(&#39;train_loss&#39;, loss, on_step=True, on_epoch=True, prog_bar=True) self.log(&#39;train_acc&#39;, self.train_acc, on_step=False, on_epoch=True, prog_bar=True, logger=True) return loss def validation_step(self, batch, batch_idx): # pylint: disable=unused-argument sentiments = batch[&#39;sentiment&#39;] logits = self.forward(batch) loss = F.cross_entropy(logits, sentiments) scores = F.softmax(logits, dim=-1) self.val_acc(scores, sentiments) self.val_f1(scores, sentiments) self.log(&#39;val_loss&#39;, loss, on_step=True, on_epoch=True, prog_bar=True) self.log(&#39;val_acc&#39;, self.val_acc, on_step=False, on_epoch=True, prog_bar=True, logger=True) self.log(&#39;val_f1&#39;, self.val_f1, on_step=False, on_epoch=True, prog_bar=True, logger=True) def test_step(self, batch, batch_idx): # pylint: disable=unused-argument sentiments = batch[&#39;sentiment&#39;] logits = self.forward(batch) scores = F.softmax(logits, dim=-1) self.test_acc(scores, sentiments) self.test_f1(scores, sentiments) self.log(&#39;test_acc&#39;, self.test_acc, on_step=False, on_epoch=True, logger=True) self.log(&#39;test_f1&#39;, self.test_f1, on_step=False, on_epoch=True, logger=True) . TC-LSTM . The architecture has a embedding layer, 2 LSTM layers and 1 dense layer. . Embedding layer: | . Convert the sequences to word vectors using pre-trained Glove word embeddings . 2 LSTM layers: | . One layer is used for the [left context + target] sequences, and one is used for the [target + right context] sequences. . Dense layer: | . We concate the 2 hidden states from the LSTM layers and feed it into the Dense layer. . The only difference compared to the TD-LSTM is its input. The input of TC-LSTM is a concatenation of the input word vector and the $v_{target}$ vector. We calculate the $v_{target}$ vector by averaging the all the target word vector(s) of the sample. For example, if the target in the sentence is jimmy carter, we tokenizer the target to jimmy and carter then convert them to word vector. After that, we average those vector to get the $v_{target}$ vector. . An overview of TC-LSTM is illustrated in Figure 2. The model extends TD-LSTM by incorporating an target con- nection component, which explicitly utilizes the connections between target word and each context word when composing the representation of a sentence. . The input of TC-LSTM is a sentence consist- ing of n words { $w_1,w_2,...w_n$ } and a target string t occurs in the sentence. We represent target t as { $w_{l+1}, w_{l+2}...w_{r−1}$ } because a target could be a word sequence of variable length, such as “google” or “harry potter”. When processing a sentence, we split it into three components:target words, preceding context words and following context words. We obtain target vector $v_{target}$ by averaging the vectors of words it contains, which has been proven to be simple and effective in representing named entities (Socher et al., 2013a; Sun et al., 2015). When compute the hidden vectors of preceding and following context words, we use two separate long short-term memory models, which are similar with the strategy used in TD-LSTM. The difference is that in TC-LSTM the input at each position is the concatenation of word embedding and target vector vtarget, while in TD-LSTM the input at each position only includes only the embedding of current word. The input data has an additional element which is the $v_{target}$ vector. Let create a new Dataset class for TC-LSTM. . from IPython.display import Image Image(filename=&#39;images/figure_2_image.png&#39;) . class TCLSTM(pl.LightningModule): def __init__(self, embeddings, hidden_size, num_layers=1, num_classes=3, batch_first=True, lr=1e-3, dropout=0, l2reg=0.01): super().__init__() embedding_dim = embeddings.shape[1] self.embedding = nn.Embedding.from_pretrained(embeddings) # load pre-trained word embeddings self.l_lstm = nn.LSTM(embedding_dim*2, hidden_size, num_layers, batch_first=batch_first, dropout=dropout) self.r_lstm = nn.LSTM(embedding_dim*2, hidden_size, num_layers, batch_first=batch_first, dropout=dropout) self.linear = nn.Linear(hidden_size*2, num_classes) self.lr = lr self.l2reg = l2reg # log hyperparameters # self.save_hyperparameters() # Define metrics self.train_acc = torchmetrics.Accuracy() self.val_acc = torchmetrics.Accuracy() self.val_f1 = torchmetrics.F1(num_classes=3, average=&#39;macro&#39;) self.test_acc = torchmetrics.Accuracy() self.test_f1 = torchmetrics.F1(num_classes=3, average=&#39;macro&#39;) def configure_optimizers(self): optim = torch.optim.Adam(self.parameters(), lr=self.lr, weight_decay=self.l2reg) return optim def forward(self, data): cols = [&#39;padded_l_sequence&#39;, &#39;padded_r_sequence&#39;, &#39;l_len&#39;, &#39;r_len&#39;, &#39;padded_target_sequence&#39;] padded_l_seqs, padded_r_seqs, l_lens, r_lens, padded_target_seqs = [data[col] for col in cols] # convert seq to word vector padded_l_embeds = self.embedding(padded_l_seqs) padded_r_embeds = self.embedding(padded_r_seqs) padded_target_embeds = self.embedding(padded_target_seqs) # BxLxH # create v_target vector and concat it to both l_embeds and r_embeds v_targets = torch.mean(padded_target_embeds, dim=1, keepdims=True) padded_l_embeds = torch.cat((padded_l_embeds, v_targets.expand((-1, padded_l_embeds.shape[1], -1))), dim=2) padded_r_embeds = torch.cat((padded_r_embeds, v_targets.expand((-1, padded_r_embeds.shape[1], -1))), dim=2) # pack the embeds padded_l_seq_pack = pack_padded_sequence(padded_l_embeds, l_lens.cpu(), batch_first=True, enforce_sorted=False) padded_r_seq_pack = pack_padded_sequence(padded_r_embeds, r_lens.cpu(), batch_first=True, enforce_sorted=False) _, (h_l, _) = self.l_lstm(padded_l_seq_pack) _, (h_r, _) = self.r_lstm(padded_r_seq_pack) h = torch.cat((h_l[-1], h_r[-1]), -1) # B x 2H out = self.linear(h) return out def training_step(self, batch, batch_idx): # pylint: disable=unused-argument sentiments = batch[&#39;sentiment&#39;] logits = self.forward(batch) loss = F.cross_entropy(logits, sentiments) scores = F.softmax(logits, dim=-1) self.train_acc(scores, sentiments) self.log(&#39;train_loss&#39;, loss, on_step=True, on_epoch=True, prog_bar=True, logger=True) self.log(&#39;train_acc&#39;, self.train_acc, on_step=True, on_epoch=True, prog_bar=True, logger=True) return loss def validation_step(self, batch, batch_idx): # pylint: disable=unused-argument sentiments = batch[&#39;sentiment&#39;] logits = self.forward(batch) loss = F.cross_entropy(logits, sentiments) scores = F.softmax(logits, dim=-1) self.val_acc(scores, sentiments) self.val_f1(scores, sentiments) self.log(&#39;val_loss&#39;, loss, on_step=True, on_epoch=True, prog_bar=True) self.log(&#39;val_acc&#39;, self.val_acc, on_step=False, on_epoch=True, prog_bar=True, logger=True) self.log(&#39;val_f1&#39;, self.val_f1, on_step=False, on_epoch=True, prog_bar=True, logger=True) def test_step(self, batch, batch_idx): # pylint: disable=unused-argument sentiments = batch[&#39;sentiment&#39;] logits = self.forward(batch) scores = F.softmax(logits, dim=-1) self.test_acc(scores, sentiments) self.test_f1(scores, sentiments) self.log(&#39;test_acc&#39;, self.test_acc, on_step=False, on_epoch=True, logger=True) self.log(&#39;test_f1&#39;, self.test_f1, on_step=False, on_epoch=True, logger=True) . LSTM . This is just a simple LSTM model with a embedding layer, 1 LSTM layers and 1 dense layer. . For the input data, we simply feed all the input word vector to the LSTM without informing the model any information of the target words. . The LSTM model solves target-dependent sentiment classification in a target- independent way. That is to say, the feature representation used for sentiment classification remains the same without considering the target words. Let us again take “I bought a new camera. The picture quality is amazing but the battery life is too short” as an example. The representations of this sentence with regard to picture quality and battery life are identical. This is evidently problematic as the sentiment polarity labels towards these two targets are different. . from IPython.display import Image Image(filename=&#39;images/figure_3_image.png&#39;) . class LSTM(pl.LightningModule): def __init__(self, embeddings, hidden_size, num_layers=1, num_classes=3, batch_first=True, lr=1e-3, dropout=0, l2reg=0.01): super().__init__() embedding_dim = embeddings.shape[1] self.embedding = nn.Embedding.from_pretrained(embeddings) # load pre-trained word embeddings self.lstm = nn.LSTM(embedding_dim, hidden_size, num_layers, batch_first=batch_first, dropout=dropout) self.linear = nn.Linear(hidden_size, num_classes) self.lr = lr self.l2reg = l2reg # Define metrics self.train_acc = torchmetrics.Accuracy() self.val_acc = torchmetrics.Accuracy() self.val_f1 = torchmetrics.F1(num_classes=3, average=&#39;macro&#39;) self.test_acc = torchmetrics.Accuracy() self.test_f1 = torchmetrics.F1(num_classes=3, average=&#39;macro&#39;) def configure_optimizers(self): optim = torch.optim.Adam(self.parameters(), lr=self.lr, weight_decay=self.l2reg) return optim def forward(self, data): cols = [&#39;padded_sequence&#39;, &#39;len&#39;] padded_seqs, lens = [data[col] for col in cols] # convert seq to word vector padded_embeds = self.embedding(padded_seqs) # pack the embeds padded_seq_pack = pack_padded_sequence(padded_embeds, lens.cpu(), batch_first=True, enforce_sorted=False) _, (h, _) = self.lstm(padded_seq_pack) out = self.linear(h[-1]) return out def training_step(self, batch, batch_idx): # pylint: disable=unused-argument sentiments = batch[&#39;sentiment&#39;] logits = self.forward(batch) loss = F.cross_entropy(logits, sentiments) scores = F.softmax(logits, dim=-1) self.train_acc(scores, sentiments) self.log(&#39;train_loss&#39;, loss, on_step=True, on_epoch=True, prog_bar=True) self.log(&#39;train_acc&#39;, self.train_acc, on_step=False, on_epoch=True, prog_bar=True, logger=True) return loss def validation_step(self, batch, batch_idx): # pylint: disable=unused-argument sentiments = batch[&#39;sentiment&#39;] logits = self.forward(batch) loss = F.cross_entropy(logits, sentiments) scores = F.softmax(logits, dim=-1) self.val_acc(scores, sentiments) self.val_f1(scores, sentiments) self.log(&#39;val_loss&#39;, loss, on_step=True, on_epoch=True, prog_bar=True) self.log(&#39;val_acc&#39;, self.val_acc, on_step=False, on_epoch=True, prog_bar=True, logger=True) self.log(&#39;val_f1&#39;, self.val_f1, on_step=False, on_epoch=True, prog_bar=True, logger=True) def test_step(self, batch, batch_idx): # pylint: disable=unused-argument sentiments = batch[&#39;sentiment&#39;] logits = self.forward(batch) scores = F.softmax(logits, dim=-1) self.test_acc(scores, sentiments) self.test_f1(scores, sentiments) self.log(&#39;test_acc&#39;, self.test_acc, on_step=False, on_epoch=True, logger=True) self.log(&#39;test_f1&#39;, self.test_f1, on_step=False, on_epoch=True, logger=True) . Training . First of all we will load the pre-trained word embedding Glove. We use the same one with the author. . We use 100-dimensional Glove vectors learned from Twitter, randomize the parameters with uniform distribution U(−0.003,0.003), set the clipping threshold of softmax layer as 200 and set learning rate as 0.01. . Since the author does not provide explicitly the hyper-parameters he used, we have to fine-tune a bit to get good result. . word_embeddings = load_pretrained_word_embeddings({&quot;name&quot;: &quot;twitter.27B&quot;, &quot;dim&quot;: 100}) . .vector_cache/glove.twitter.27B.zip: 1.52GB [04:53, 5.18MB/s] 100%|█████████▉| 1191916/1193514 [00:43&lt;00:00, 27135.96it/s] . download_url(TRAIN_DS_URL, &quot;train.raw&quot;, &quot;download/raw_data&quot;) download_url(TEST_DS_URL, &quot;test.raw&quot;, &quot;download/raw_data&quot;) train_data = _load_data_from(&quot;download/raw_data/train.raw&quot;) test_data = _load_data_from(&quot;download/raw_data/test.raw&quot;) # Build vocabulary for the dataset all_sentences = train_data[0] + test_data[0] all_targets = train_data[1] + test_data[1] tokenizer = Tokenizer(get_tokenizer(&quot;basic_english&quot;)) build_vocab(tokenizer, [all_sentences, all_targets]) # Create datamodule options = { &quot;on_gpu&quot;: True, &quot;batch_size&quot;: 64, &quot;num_workers&quot;: 2 } datamodule = Twitter(tokenizer, options) # Create embedding matrix embedding_matrix = create_embedding_matrix(word_embeddings, tokenizer.vocab, &quot;embedding_matrix.dat&quot;) . TD-LSTM . checkpoint_callback = ModelCheckpoint( monitor=&#39;val_acc&#39;, # save the model with the best validation accuracy dirpath=&#39;checkpoints&#39;, mode=&#39;max&#39;, ) tb_logger = pl_loggers.TensorBoardLogger(&#39;logs/&#39;) # create logger for tensorboard # Set hyper-parameters lr = 1e-3 hidden_size = 300 num_epochs = 30 l2reg = 0.0 trainer = pl.Trainer(gpus=1, max_epochs=num_epochs, logger=tb_logger, callbacks=[checkpoint_callback], deterministic=True) # trainer = pl.Trainer(fast_dev_run=True) #Debug # trainer = pl.Trainer(overfit_batches=0.1, max_epochs=30) #Debug model = TDLSTM(embedding_matrix, hidden_size, lr=lr, l2reg=l2reg) trainer.fit(model, datamodule) . GPU available: True, used: True TPU available: False, using: 0 TPU cores . loading embedding matrix from embedding_matrix.dat . LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0] | Name | Type | Params - 0 | embedding | Embedding | 1.3 M 1 | l_lstm | LSTM | 482 K 2 | r_lstm | LSTM | 482 K 3 | linear | Linear | 1.8 K 4 | train_acc | Accuracy | 0 5 | val_acc | Accuracy | 0 6 | val_f1 | F1 | 0 7 | test_acc | Accuracy | 0 8 | test_f1 | F1 | 0 - 966 K Trainable params 1.3 M Non-trainable params 2.3 M Total params 9.235 Total estimated model params size (MB) Global seed set to 2401 . . new_model = TDLSTM.load_from_checkpoint(checkpoint_callback.best_model_path, embeddings=embedding_matrix, hidden_size=300) trainer.test(new_model, datamodule.test_dataloader()) . LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0] . -- DATALOADER:0 TEST RESULTS {&#39;test_acc&#39;: 0.6979768872261047, &#39;test_f1&#39;: 0.6850955486297607} -- . [{&#39;test_acc&#39;: 0.6979768872261047, &#39;test_f1&#39;: 0.6850955486297607}] . TC-LSTM . checkpoint_callback_2 = ModelCheckpoint( monitor=&#39;val_acc&#39;, # save the model with the best validation accuracy dirpath=&#39;checkpoints&#39;, mode=&#39;max&#39;, ) tb_logger = pl_loggers.TensorBoardLogger(&#39;logs/&#39;) # create logger for tensorboard # Set hyper-parameters lr = 1e-3 hidden_size = 300 num_epochs = 30 l2reg = 0.0 trainer = pl.Trainer(gpus=1, max_epochs=num_epochs, logger=tb_logger, callbacks=[checkpoint_callback_2]) # trainer = pl.Trainer(fast_dev_run=True) #Debug # trainer = pl.Trainer(overfit_batches=0.1, max_epochs=30) #Debug model = TCLSTM(embedding_matrix, hidden_size, lr=lr, l2reg=l2reg) trainer.fit(model, datamodule) . GPU available: True, used: True TPU available: False, using: 0 TPU cores LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0] | Name | Type | Params - 0 | embedding | Embedding | 1.3 M 1 | l_lstm | LSTM | 602 K 2 | r_lstm | LSTM | 602 K 3 | linear | Linear | 1.8 K 4 | train_acc | Accuracy | 0 5 | val_acc | Accuracy | 0 6 | val_f1 | F1 | 0 7 | test_acc | Accuracy | 0 8 | test_f1 | F1 | 0 - 1.2 M Trainable params 1.3 M Non-trainable params 2.5 M Total params 10.195 Total estimated model params size (MB) Global seed set to 2401 . . new_model = TCLSTM.load_from_checkpoint(checkpoint_callback_2.best_model_path, embeddings=embedding_matrix, hidden_size=300) trainer.test(new_model, datamodule.test_dataloader()) . LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0] . -- DATALOADER:0 TEST RESULTS {&#39;test_acc&#39;: 0.7008670568466187, &#39;test_f1&#39;: 0.6788402199745178} -- . [{&#39;test_acc&#39;: 0.7008670568466187, &#39;test_f1&#39;: 0.6788402199745178}] . LSTM . checkpoint_callback_3 = ModelCheckpoint( monitor=&#39;val_acc&#39;, # save the model with the best validation accuracy dirpath=&#39;checkpoints&#39;, mode=&#39;max&#39;, ) tb_logger = pl_loggers.TensorBoardLogger(&#39;logs/&#39;) # create logger for tensorboard # Set hyper-parameters lr = 1e-3 hidden_size = 300 num_epochs = 30 l2reg = 0.0 trainer = pl.Trainer(gpus=1, max_epochs=num_epochs, logger=tb_logger, callbacks=[checkpoint_callback_3]) # trainer = pl.Trainer(fast_dev_run=True) #Debug # trainer = pl.Trainer(overfit_batches=0.1, max_epochs=30) #Debug model = LSTM(embedding_matrix, hidden_size, lr=lr, l2reg=l2reg) trainer.fit(model, datamodule) . GPU available: True, used: True TPU available: False, using: 0 TPU cores LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0] | Name | Type | Params - 0 | embedding | Embedding | 1.3 M 1 | lstm | LSTM | 482 K 2 | linear | Linear | 903 3 | train_acc | Accuracy | 0 4 | val_acc | Accuracy | 0 5 | val_f1 | F1 | 0 6 | test_acc | Accuracy | 0 7 | test_f1 | F1 | 0 - 483 K Trainable params 1.3 M Non-trainable params 1.8 M Total params 7.302 Total estimated model params size (MB) Global seed set to 2401 . . new_model = LSTM.load_from_checkpoint(checkpoint_callback_3.best_model_path, embeddings=embedding_matrix, hidden_size=300) trainer.test(new_model, datamodule.test_dataloader()) . LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0] . -- DATALOADER:0 TEST RESULTS {&#39;test_acc&#39;: 0.6878612637519836, &#39;test_f1&#39;: 0.6633064150810242} -- . [{&#39;test_acc&#39;: 0.6878612637519836, &#39;test_f1&#39;: 0.6633064150810242}] . Discussion . Our result: . Method Accuracy Macro-F1 . LSTM | 0.687 | 0.66 | . TD-LSTM | 0.697 | 0.685 | . TC-LSTM | 0.7 | 0.679 | . Paper result: . Method Accuracy Macro-F1 . LSTM | 0.665 | 0.647 | . TD-LSTM | 0.708 | 0.690 | . TC-LSTM | 0.715 | 0.695 | . Firstly, compared to the result from the paper, our implementation gets very close results. You can try to tune the model to get a better result. . Secondly, it is surprising that we can get a much better result with the simple LSTM model compared to the paper result. The reason that the LSTM can get a very close result compared to TD-LSTM and TC-LSTM is explainable. Even though this is the target-dependent sentiment classification task, there is only one target per sentence in the dataset. Therefore, the target information is redundant in this case. The LSTM model can use the surrounding words to classify the sentence. . You can read more about the paper here . from IPython.display import Image Image(filename=&#39;images/results.png&#39;) . Lessons . Even though the embedding layer is frozen during traning (parameters not updated), using the corpus vocab to create embedding matrix from pretrained Glove yield better result than using the whole word embeddings for the embedding layer. . | Using pad_sequence and pack_padded_sequence assure the LSTM/RNN/GRU not processing the padding token. It is better than padding with max length. The result of 2 methods are the same. From what I search, padding with max length will adversely affect the performance of the model. Even though, we can set the loss function to not to account for the padding token, the padding token still have affect on the input tokens. The reason may be that the latter will process the padding token together with the input ones. . | Consider the structure of the project before coding it to save refactoring time. . |",
            "url": "https://minhdang241.github.io/minhdg-blog/implementation/2021/06/20/NLP_2_Effective_LSTMs_for_Target_Dependent_Sentiment_Classification-Part-2.html",
            "relUrl": "/implementation/2021/06/20/NLP_2_Effective_LSTMs_for_Target_Dependent_Sentiment_Classification-Part-2.html",
            "date": " • Jun 20, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Effective LSTMs for Target Dependent Sentiment Classification [Part 1]",
            "content": "from IPython.display import Image Image(filename=&#39;images/paper_image.png&#39;) . Target-Dependent Sentiment Classification is one of the text classification problems in the field of sentiment analysis. Given a sentence and a target to the model, it has to output the sentiment polarity (e.g positive, negative, neutral) of the sentence towards that target. For example, we have a sentence &quot;I bout a new camera. The pucture quality is amazing but the battery life is too short&quot;. If we input the target picture quality, we expect the sentiment to be &quot;positive&quot;. On the other hand, if we input the target battery life, we expect the sentiment to be &quot;negative&quot;. . The author argues that the Target-Dependent sentiment classification is challenging since it is hard to effectively model the sentiment relatedness of a target word with its context words in a sentence. Doing feature engineerings are clumsy, so they propose a neural network approach with 2 models Target-Dependent LSTM (TD-LSTM) and Target-Connection LSTM(TC-LSTM). . In this post, I will implement those models and compare it with the plain LSTM model, just like they did. Yet, I will not cover other approaches using SVM and RNN. Since in the original paper, the author did not provide the specific hyper-parameters they used for their models, I will fine-tune it on my own. . This post covers the data processing step and the implementation of TD-LSTM. The second post will cover the implementation of TC-LSTM and comparision between three models: TC-LSTM, TD-LSTM, and LSTM. . The full notebook is available here. . Install required packages . %%capture !pip install pytorch-lightning !pip install torchmetrics # !pip install transformers . Download dataset and pretrained word-embedding . First of all you should download the dataset. The dataset used in the paper is from the Twitter (Dong et al., 2014). You can download from here. After downloading, you should unzip the dataset file in the same folder with the notebook. They should be in the same folder to run properly. . %%capture !unzip acl-14-short-data.zip . In the paper, the author used the 100-dimensional Glove vectors learned from Twitter. Download the word embedding file and unzip it in the same folder with the notebook. . %%capture !wget https://nlp.stanford.edu/data/glove.twitter.27B.zip !unzip glove.twitter.27B.zip . Import required packages . import numpy as np import pytorch_lightning as pl import torch import torch.nn as nn import torch.nn.functional as F import torchmetrics from pytorch_lightning import loggers as pl_loggers from pytorch_lightning.callbacks import ModelCheckpoint from torch.utils.data import DataLoader, Dataset, random_split from torchtext.data import get_tokenizer . Load dataset from file and create dataloaders . =====Dataset File Format===== . Each instance consists three lines: . sentence (the target is replaced with $T$) | target | polarity label (0: neutral, 1:positive, -1:negative) | . Example: . i agree about arafat . i mean , shit , they even gave one to $T$ ha . it should be called &#39;&#39; the worst president &#39;&#39; prize . . jimmy carter . -1 . Target-Dependent LSTM (TD-LSTM) . The LSTM model solves target-dependent sentiment classification in a target- independent way. That is to say, the feature representation used for sentiment classification remains the same without considering the target words. Let us again take “I bought a new camera. The picture quality is amazing but the battery life is too short” as an example. The representations of this sentence with regard to picture quality and battery life are identical. This is evidently problematic as the sentiment polarity labels towards these two targets are different. . To take into account of the target information, we make a slight modification on the aforementioned LSTM model and introduce a target-dependent LSTM (TD-LSTM) in this subsection. The basic idea is to model the preceding and following contexts surrounding the target string, so that contexts in both directions could be used as feature representations for sentiment classification. We believe that capturing such target-dependent context information could improve the accuracy of target-dependent sentiment classification. . Specifically, we use two LSTM neural networks, a left one LSTML and a right one LSTMR, to model the preceding and following contexts respectively. An illustration of the model is shown in Figure 1. The input of LSTML is the preceding contexts plus target string, and the input of LSTMR is the following contexts plus target string. We run LSTML from left to right, and run LSTMR from right to left. We favor this strategy as we believe that regarding target string as the last unit could better utilize the semantics of target string when using the composed representation for sentiment classification. Afterwards, we concatenate the last hidden vectors of LSTML and LSTMR , and feed them to a sof tmax layer to classify the sentiment polarity label. One could also try averaging or summing the last hidden vectors of LSTML and LSTMR as alternatives. . from IPython.display import Image Image(filename=&#39;images/firgure_1_image.png&#39;) . class TwitterTDLSTMDataset(Dataset): def __init__(self, l_sequences, r_sequences, l_lens, r_lens, sentiments): self.l_sequences = l_sequences self.r_sequences = r_sequences self.l_lens = l_lens self.r_lens = r_lens self.sentiments = sentiments def __len__(self): return len(self.sentiments) def __getitem__(self, idx): return (self.l_sequences[idx], self.l_lens[idx]), (self.r_sequences[idx], self.r_lens[idx]), self.sentiments[idx] . def create_dataset_from(path: str): &quot;&quot;&quot; Create a dataset from a file path Return: a TwitterDataset object &quot;&quot;&quot; sentences = [] targets = [] sentiments = [] with open(path) as f: lines = f.readlines() # Read the file line by line and # check the relative index to parse the data according to the format. for i, line in enumerate(lines): index = i % 3 # compute the relative index if index == 0: sentences.append(line[:-1]) elif index == 1: targets.append(line[:-1]) elif index == 2: sentiments.append(line.strip()) #Load tokenizer tokenizer = get_tokenizer(&quot;basic_english&quot;) #Tokenize and Lower sentence and target text tokenized_sentences = list(map(lambda x: tokenizer(x), sentences)) targets = list(map(lambda x: tokenizer(x), targets)) #Convert sentiment text to number sentiments = list(map(lambda x: int(x), sentiments)) #Generate sequence_l, sequence_r l_sequences = [] r_sequences = [] for i, sent in enumerate(tokenized_sentences): seq_l, seq_r = [], [] flag = True for token in sent: if word_2_id.get(token) == len(word_2_id) - 1: flag = False continue if flag: # get the index of the token in the vocab # if the token does not exists in the vocab, return index of &lt;UNK&gt; token seq_l.append(word_2_id.get(token, 1)) else: seq_r.append(word_2_id.get(token, 1)) target_seq = [word_2_id.get(token, 1) for token in targets[i]] seq_l = torch.tensor(seq_l + target_seq) seq_r = torch.tensor((target_seq + seq_r)[::-1]) # reverse the seq_r l_sequences.append(seq_l) r_sequences.append(seq_r) l_lens = torch.tensor([len(seq) for seq in l_sequences]) r_lens = torch.tensor([len(seq) for seq in r_sequences]) sentiments = torch.tensor(sentiments) + 1 assert len(l_lens) == len(l_sequences) assert len(r_lens) == len(r_sequences) assert len(l_lens) == len(sentiments) return TwitterTDLSTMDataset(l_sequences, r_sequences, l_lens, r_lens, sentiments) . def load_w2v(embedding_file_path: str): &quot;&quot;&quot; Load pretrained word-embeddings from a file path Return a word_2_id dictionary and a embedding matrix &quot;&quot;&quot; word_2_id = {&#39;&lt;PAD&gt;&#39;: 0, &#39;&lt;UNK&gt;&#39;: 1} embeddings = [torch.zeros(100), torch.zeros(100)] with open(embedding_file_path) as f: for i, line in enumerate(f.readlines()): tokens = line.split() word, vec = &#39; &#39;.join(tokens[:-100]), tokens[-100:] word_2_id[word] = i + 2 # convert list of str to float float_tokens = np.array(vec, dtype=float) embeddings.append(torch.tensor(float_tokens, dtype=torch.float)) embeddings = torch.stack(embeddings) embeddings[word_2_id[&#39;&lt;UNK&gt;&#39;]] = torch.mean(embeddings[2:], dim=0) word_2_id[&#39;$t$&#39;] = len(word_2_id) return word_2_id, embeddings . word_2_id, embeddings = load_w2v(&quot;glove.twitter.27B.100d.txt&quot;) . from torch.nn.utils.rnn import pad_sequence, pack_padded_sequence, pad_packed_sequence def collate_batch(batch): &quot;&quot;&quot; Combine samples from dataset into a batch &quot;&quot;&quot; l_sequences = [] l_lens = [] r_sequences = [] r_lens = [] sentiments = [] for (l_sequence, l_len), (r_sequence, r_len), sentiment in batch: l_sequences.append(l_sequence) l_lens.append(l_len) r_sequences.append(r_sequence) r_lens.append(r_len) sentiments.append(sentiment) padded_l_seq = pad_sequence(l_sequences, batch_first=True, padding_value=0) padded_r_seq = pad_sequence(r_sequences, batch_first=True, padding_value=0) return (padded_l_seq, l_lens), (padded_r_seq, r_lens), torch.tensor(sentiments) . In the paper, the author trained the model on training set, and evaluated the performance on test set . dataset = create_dataset_from(&quot;/content/acl-14-short-data/train.raw&quot;) dataloaders = DataLoader(dataset, batch_size=128, collate_fn=collate_batch) . test_dataset = create_dataset_from(&quot;/content/acl-14-short-data/test.raw&quot;) test_dataloaders = DataLoader(test_dataset, batch_size=64, collate_fn=collate_batch) . Implement Model Architecture . The architecture has a embedding layer, 2 LSTM layers and 1 dense layer. . Embedding layer: | . Convert the sequences to word vectors using pre-trained Glove word embeddings . 2 LSTM layers: | . One layer is used for the [left context + target] sequences, and one is used for the [target + right context] sequences. . Dense layer: | . We concate the 2 hidden states from the LSTM layers and feed it into the Dense layer. . Notes: . We use Adam as our optimizer and using accuracy and f1 as our evaluating metrics, just like in the original paper. . class TDLSTM(pl.LightningModule): def __init__(self, embeddings, hidden_size, num_layers=1, num_classes=3, batch_first=True, lr=1e-3, dropout=0, l2reg=0.01): super().__init__() embedding_dim = embeddings.shape[1] self.embedding = nn.Embedding.from_pretrained(embeddings) # load pre-trained word embeddings self.l_lstm = nn.LSTM(embedding_dim, hidden_size, num_layers, batch_first=batch_first, dropout=dropout) self.r_lstm = nn.LSTM(embedding_dim, hidden_size, num_layers, batch_first=batch_first, dropout=dropout) self.linear = nn.Linear(hidden_size*2, num_classes) self.lr = lr self.l2reg = l2reg # Define metrics self.train_acc = torchmetrics.Accuracy() self.val_acc = torchmetrics.Accuracy() self.val_f1 = torchmetrics.F1(num_classes=3, average=&#39;macro&#39;) self.test_acc = torchmetrics.Accuracy() self.test_f1 = torchmetrics.F1(num_classes=3, average=&#39;macro&#39;) def configure_optimizers(self): optim = torch.optim.AdamW(self.parameters(), lr=self.lr, weight_decay=self.l2reg) return optim def forward(self, padded_l_seqs, l_lens, padded_r_seqs, r_lens): # convert seq to word vector padded_l_embeds = self.embedding(padded_l_seqs) padded_r_embeds = self.embedding(padded_r_seqs) # pack the embeds padded_l_seq_pack = pack_padded_sequence(padded_l_embeds, l_lens, batch_first=True, enforce_sorted=False) padded_r_seq_pack = pack_padded_sequence(padded_r_embeds, r_lens, batch_first=True, enforce_sorted=False) _, (h_l, _) = self.l_lstm(padded_l_seq_pack) _, (h_r, _) = self.r_lstm(padded_r_seq_pack) h = torch.cat((h_l[-1], h_r[-1]), -1) # B x 2H out = self.linear(h) return out def training_step(self, batch, batch_idx): # pylint: disable=unused-argument (padded_l_seqs, l_lens), (padded_r_seqs, r_lens), sentiments = batch logits = self.forward(padded_l_seqs, l_lens, padded_r_seqs, r_lens) loss = F.cross_entropy(logits, sentiments) scores = F.softmax(logits, dim=-1) self.train_acc(scores, sentiments) self.log(&#39;train_loss&#39;, loss, on_step=True, on_epoch=True, prog_bar=True) self.log(&#39;train_acc&#39;, self.train_acc, on_step=False, on_epoch=True, prog_bar=True, logger=True) return loss def validation_step(self, batch, batch_idx): # pylint: disable=unused-argument (padded_l_seqs, l_lens), (padded_r_seqs, r_lens), sentiments = batch logits = self.forward(padded_l_seqs, l_lens, padded_r_seqs, r_lens) loss = F.cross_entropy(logits, sentiments) scores = F.softmax(logits, dim=-1) self.val_acc(scores, sentiments) self.val_f1(scores, sentiments) self.log(&#39;val_loss&#39;, loss, on_step=True, on_epoch=True, prog_bar=True) self.log(&#39;val_acc&#39;, self.val_acc, on_step=False, on_epoch=True, prog_bar=True, logger=True) self.log(&#39;val_f1&#39;, self.val_f1, on_step=False, on_epoch=True, prog_bar=True, logger=True) def test_step(self, batch, batch_idx): # pylint: disable=unused-argument (padded_l_seqs, l_lens), (padded_r_seqs, r_lens), sentiments = batch logits = self.forward(padded_l_seqs, l_lens, padded_r_seqs, r_lens) scores = F.softmax(logits, dim=-1) self.test_acc(scores, sentiments) self.test_f1(scores, sentiments) self.log(&#39;test_acc&#39;, self.test_acc, on_step=False, on_epoch=True, logger=True) self.log(&#39;test_f1&#39;, self.test_f1, on_step=False, on_epoch=True, logger=True) . Training . checkpoint_callback = ModelCheckpoint( monitor=&#39;val_acc&#39;, # save the model with the best validation accuracy dirpath=&#39;checkpoints&#39;, filename=&#39;best_model&#39;, mode=&#39;max&#39;, ) tb_logger = pl_loggers.TensorBoardLogger(&#39;logs/&#39;) # create logger for tensorboard # hyper-parameters lr = 1e-3 hidden_size = 500 num_epochs = 60 l2reg = 0.5 trainer = pl.Trainer(gpus=1, max_epochs=num_epochs, logger=tb_logger, callbacks=[checkpoint_callback]) model = TDLSTM(embeddings, hidden_size, lr=lr, l2reg=l2reg) trainer.fit(model, dataloaders, test_dataloaders) . GPU available: True, used: True TPU available: False, using: 0 TPU cores LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0] | Name | Type | Params - 0 | embedding | Embedding | 119 M 1 | l_lstm | LSTM | 1.2 M 2 | r_lstm | LSTM | 1.2 M 3 | linear | Linear | 3.0 K 4 | train_acc | Accuracy | 0 5 | val_acc | Accuracy | 0 6 | val_f1 | F1 | 0 7 | test_acc | Accuracy | 0 8 | test_f1 | F1 | 0 - 2.4 M Trainable params 119 M Non-trainable params 121 M Total params 487.050 Total estimated model params size (MB) . . new_model = TDLSTM.load_from_checkpoint(checkpoint_callback.best_model_path, embeddings=embeddings, hidden_size=500) trainer.test(new_model, test_dataloaders) . LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0] . -- DATALOADER:0 TEST RESULTS {&#39;test_acc&#39;: 0.7037572264671326, &#39;test_f1&#39;: 0.6847572326660156} -- . [{&#39;test_acc&#39;: 0.7037572264671326, &#39;test_f1&#39;: 0.6847572326660156}] . from IPython.display import Image Image(filename=&#39;images/results.png&#39;) . Compare to the result from the paper, our implementation gets very close results. You can try to tune the model to get better result. .",
            "url": "https://minhdang241.github.io/minhdg-blog/implementation/2021/06/18/NLP_1_Effective_LSTMs_for_Target_Dependent_Sentiment_Classification-Part-1.html",
            "relUrl": "/implementation/2021/06/18/NLP_1_Effective_LSTMs_for_Target_Dependent_Sentiment_Classification-Part-1.html",
            "date": " • Jun 18, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://minhdang241.github.io/minhdg-blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://minhdang241.github.io/minhdg-blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi, Im Minh. Welcome to my NLP365 project. This is where I document all the things I have learned and researched about NLP and ML in general. .",
          "url": "https://minhdang241.github.io/minhdg-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://minhdang241.github.io/minhdg-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}